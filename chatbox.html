<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ChatGPT Search Fixes</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" />
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      background-color: #f7f7f8;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .chat-header {
      padding: 1rem;
      background-color: #343541;
      color: white;
      text-align: center;
      font-size: 1.2rem;
      font-weight: bold;
    }

    .chat-container {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      background-color: white;
    }

    .message {
      max-width: 80%;
      padding: 0.75rem 1rem;
      border-radius: 8px;
      line-height: 1.4;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .incoming {
      background-color: #e4e4e7;
      align-self: flex-start;
      color: #000;
    }

    .outgoing {
      background-color: #10a37f;
      color: white;
      align-self: flex-end;
    }

    .chat-input {
      padding: 1rem;
      background-color: white;
      border-top: 1px solid #ccc;
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .chat-input input[type="text"] {
      flex: 1;
      padding: 0.75rem 1rem;
      border: 1px solid #ccc;
      border-radius: 6px;
      font-size: 1rem;
      min-width: 200px;
    }

    #fileSelect {
      min-width: 250px;
      height: 36px;
      padding: 6px 10px;
      border: 1px solid #ccc;
      border-radius: 6px;
      background-color: #fff;
      font-size: 14px;
      font-family: Arial, sans-serif;
      cursor: pointer;
      transition: border-color 0.3s ease;
    }

    #fileSelect:focus {
      outline: none;
      border-color: #4a90e2;
      box-shadow: 0 0 4px rgba(74, 144, 226, 0.6);
    }

    .chat-input button {
      background-color: #10a37f;
      border: none;
      color: white;
      padding: 0.75rem 1rem;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .chat-input button:hover {
      background-color: #0e8a6b;
    }

    button.clear-history {
      float: right;
      background: none;
      color: #343541;
      border: none;
      cursor: pointer;
      font-size: 1.2rem;
      margin: 0.5rem 1rem 0 0;
    }
  </style>
</head>
<body>

  <div class="chat-header">CHAT OF CONTENT</div>

  <div class="chat-container" id="chatContainer">
    <div class="message incoming">Xin ch√†o! Nh·∫≠p t·ª´ kh√≥a ho·∫∑c ch·ªçn file ƒë·ªÉ t√¨m ki·∫øm.</div>
  </div>

  <div class="chat-input">
    <input
      type="text"
      id="userInput"
      placeholder="Nh·∫≠p t·ª´ kh√≥a..."
      onkeypress="if(event.key === 'Enter') sendMessage()"
      autocomplete="off"
    />
    <select id="fileSelect">
      <option value="">-- Ch·ªçn file --</option>
    </select>

    <!-- Input ch·ªçn file TXT -->
<input type="file" id="txtFileInput" accept=".txt" multiple style="min-width: 200px;" />


    <button onclick="sendMessage()">
      <i class="fa fa-paper-plane" aria-hidden="true"></i>
    </button>

    <button onclick="convertTxtToJson()" title="Chuy·ªÉn file TXT th√†nh JSON">
      üìÑ‚û°Ô∏èüìä
    </button>
  </div>

  <button class="clear-history" title="X√≥a l·ªãch s·ª≠ chat" onclick="clearChatHistory()">üóë</button>

<script>
  let fixesData = [];
  const existingMessages = new Set();

  window.onload = function () {
    restoreHistoryFromLocalStorage();

    fetch('content/fixes.json')
      .then(response => {
        if (!response.ok) throw new Error('Kh√¥ng th·ªÉ t·∫£i fixes.json');
        return response.json();
      })
      .then(data => {
        fixesData = data;
        populateFileSelect();
      })
      .catch(err => {
        addMessage("L·ªói khi t·∫£i file JSON: " + err.message, "incoming");
      });
  };

  function populateFileSelect() {
    const select = document.getElementById('fileSelect');
    select.innerHTML = '<option value="">-- Ch·ªçn file --</option>';
    fixesData.forEach((file, idx) => {
      const option = document.createElement('option');
      option.value = idx;
      option.textContent = file.file;
      select.appendChild(option);
    });
  }

  function sendMessage() {
    const input = document.getElementById('userInput');
    const select = document.getElementById('fileSelect');

    let filename = input.value.trim();
    if (!filename && select.value !== "") {
      filename = select.options[select.selectedIndex].text.trim();
    }

    if (!filename) return;

    addMessage(filename, 'outgoing');

    if (input.value.trim()) {
      input.value = '';
    }
    if (select.value !== "") {
      select.value = '';
    }

    if (fixesData.length === 0) {
      addMessage("D·ªØ li·ªáu ch∆∞a ƒë∆∞·ª£c t·∫£i. Vui l√≤ng th·ª≠ l·∫°i sau.", "incoming");
      return;
    }

    const item = fixesData.find(i => i.file === filename);

    if (!item) {
      addMessage(`Kh√¥ng t√¨m th·∫•y file "${filename}" trong d·ªØ li·ªáu.`, 'incoming');
    } else {
      const formattedContent = item.content.replace(/\r\n/g, '\n');
      addMessage(`üìÑ ${item.file}\n\n${formattedContent}`, 'incoming', true);
    }
  }

  function addMessage(text, type, isPreformatted = false) {
    const key = JSON.stringify({ text, type, isPreformatted });
    if (existingMessages.has(key)) {
      return;
    }
    existingMessages.add(key);

    const chatContainer = document.getElementById('chatContainer');
    const msgDiv = document.createElement('div');
    msgDiv.className = `message ${type}`;

    text = text.replace(/\\r\\n/g, '\n').replace(/\\n/g, '\n');

    if (isPreformatted) {
      const pre = document.createElement('pre');
      pre.style.whiteSpace = 'pre-wrap';
      pre.textContent = text;
      msgDiv.appendChild(pre);
    } else {
      msgDiv.innerHTML = text.replace(/\r\n|\n/g, "<br>");
    }

    chatContainer.appendChild(msgDiv);
    chatContainer.scrollTop = chatContainer.scrollHeight;

    saveHistoryToLocalStorage(text, type, isPreformatted);
  }

  function saveHistoryToLocalStorage(text, type, isPreformatted) {
    let history = JSON.parse(localStorage.getItem('chatHistory') || '[]');
    const key = JSON.stringify({ text, type, isPreformatted });
    const exists = history.some(msg => JSON.stringify(msg) === key);
    if (!exists) {
      history.push({ text, type, isPreformatted });
      localStorage.setItem('chatHistory', JSON.stringify(history));
    }
  }

  function restoreHistoryFromLocalStorage() {
    const history = JSON.parse(localStorage.getItem('chatHistory') || '[]');
    for (const msg of history) {
      addMessage(msg.text, msg.type, msg.isPreformatted);
    }
  }

  function clearChatHistory() {
    localStorage.removeItem('chatHistory');
    existingMessages.clear();
    document.getElementById('chatContainer').innerHTML = '';
  }

  // H√†m chuy·ªÉn file TXT th√†nh JSON
function convertTxtToJson() {
  const fileInput = document.getElementById('txtFileInput');
  if (!fileInput.files.length) {
    alert('Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt file TXT ƒë·ªÉ chuy·ªÉn ƒë·ªïi.');
    return;
  }

  const txtFiles = Array.from(fileInput.files).filter(file => file.name.endsWith('.txt'));
  if (txtFiles.length === 0) {
    alert('Vui l√≤ng ch·ªçn file c√≥ ƒë·ªãnh d·∫°ng .txt');
    return;
  }

  const allFilesData = [];
  let filesProcessed = 0;

  txtFiles.forEach(file => {
    const reader = new FileReader();

    reader.onload = function(e) {
      const content = e.target.result; // gi·ªØ nguy√™n chu·ªói file txt g·ªëc
      allFilesData.push({
        file: file.name,
        content: content
      });

      filesProcessed++;

      if (filesProcessed === txtFiles.length) {
        // T·∫°o JSON m·∫£ng thu·∫ßn t√∫y
        const jsonString = JSON.stringify(allFilesData, null, 2);

        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'merged_files.json';

        document.body.appendChild(a);
        a.click();

        setTimeout(() => {
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }, 100);

        addMessage(`üìÑ ƒê√£ chuy·ªÉn v√† t·∫£i file JSON g·ªôp: merged_files.json`, 'incoming');
      }
    };

    reader.onerror = function() {
      alert(`L·ªói khi ƒë·ªçc file: ${file.name}`);
    };

    reader.readAsText(file);
  });
}




</script>

</body>
</html>
